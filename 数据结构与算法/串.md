## 串
### KMP
利用next数组+前缀和(看自制视频~)
```C++
int getIndexOf(string s, string m) {
    if (s.empty() || m.empty() || m.length() < 1 || s.length() < m.length()) {
        return -1;     // s主串，m子串， 不合法情况直接返回-1
    }
    vector<char> str1(s.begin(), s.end());    // 转为字符数组
    vector<char> str2(m.begin(), m.end());    
    int i1 = 0;      int i2 = 0;              // i1: 主串指针  i2: 子串指针
    vector<int> next = getNextArray(str2);    // 拿到next数组
    while (i1 < str1.size() && i2 < str2.size()) {
        if (str1[i1] == str2[i2]) {           // 1.主串子串匹配成功，指针共同往后移
            i1++;   i2++;
        } else if (i2 == 0) {                 // 2.子串指针来到开头，无法再往前跳，
            i1++;                             //   只能主串指针往前跳
        } else {
            i2 = next[i2];                    // 3.子串根据next数组往前跳到指定位置
        }
    }         // 是哪个指针先越界导致退出while循环？ 如果是i1，说明找到了子串，返回位置; 否则找不到，返回-1
    return i2 == str2.size() ? i1 - i2 : -1;  // 位置就是主串指针位置-子串长度 = 子串开头位置
}
vector<int> getNextArray(vector<char>& ms) {
    if (ms.size() == 1) {
        return vector<int>{-1};      // 长度为1单独设置
    }
    vector<int> next(ms.size(), 0);
    next[0] = -1;                    // next数组前两位默认是这两个值
    next[1] = 0;
    int i = 2;
    int cn = 0;                      // cn: 当前最长公共前缀的大小
    while (i < next.size()) {
        if (ms[i - 1] == ms[cn]) {   // 有共同前后缀，不断累加
            next[i++] = ++cn;        
        } else if (cn > 0) {         // 前一个字符有公共前后缀，这个突然
            cn = next[cn];           // 没有了，cn要回退，重写计算前缀
        } else {
            next[i++] = 0;           // 前一个字符str[i-1] != str[0]
        }                            // 说明没有共同前缀，设置为0
    }
    return next;
}
```
### 并查集
在图中有应用到，但这种集合操作不局限于图，还有数组、树的合并等等，所以更倾向于串的范畴
### 字典树/前缀树
### AC自动机
### BM搜索
### 后缀数组