# 哈希表(散列表)
### 哈希表
增删改查的时间复杂度：O(1),只不过常数时间比较大  
有键无值HashSet(C++: UnOrderedSet),有键有值HashMap(C++: UnOrderedMap)  
根据键key,利用哈斯算法,得到对应的数字i（索引），找到对应的内存地址（arr[i]）,得到哈希表的value值  
python中的字典dict也是利用哈希表来实现的  
```C++
// 创建哈希表
unordered_map<char, int> hashMap;
// 添加键值对
hashMap['a'] = 2;
hashMap['b'] = 3;
hashMap['c'] = 5;
// 获取键对应的值
int value = hashMap['a'];
// 检查键是否存在
bool containsKey = (hashMap.find('a') != hashMap.end());
// 检查值是否存在
bool containsValue = false;
for (const auto& kv : hashMap) {
    if (kv.second == value) {
        containsValue = true;
        break;
    }
}
// 删除键值对
hashMap.erase('a');
// 获取哈希表中的键集合
unordered_set<char> keySet;
for (const auto& kv : hashMap) {
    keySet.insert(kv.first);
}
cout << "Keys: ";
for (const auto& key : keySet) {
    cout << "'" << key << "' ";
}
// 获取哈希表中的值集合
vector<int> values;
for (const auto& kv : hashMap) {
    values.push_back(kv.second);
}
cout << "Values: ";
for (const auto& value : values) {
    cout << value << " ";
}
// 获取哈希表中的键值对集合
cout << "Entries: ";
for (const auto& kv : hashMap) {
    cout << "Key: " << kv.first << ", Value: " << kv.second << endl;
}
// 获取键 'b' 对应的值，如果不存在则返回默认值 0
int Count = hashMap['b'];
cout << "b count: " << Count << endl;
// 获取哈希表的大小（键值对数量）
int size = hashMap.size();
// 清空哈希表
hashMap.clear();
```
### 特点
1.无限输入对应有限输出 MD5 是0-2^64-1范围的输出，SHA1是0-2^128-1范围的输出  
2.相同的输入必定有相同的输出，不随机  
3.不同输入也可能有相同的输出，称为哈希碰撞，概率很小，可能现在产生的值，以后一生都不会再遇见  
4.相似输入会得到离散输出，均匀分布无规律，离散性越好，哈希函数越优秀  
#### 词频统计
40亿个不同的数，统计出现次数最多的数，返回其出现的次数（内存空间只有1G）
先hash，再%100，再分到100个文件里(有碰撞无所谓，下一步骤会在一个文件中具体对那些数进行词频统计的！)  
先处理一个文件，统计拿到其出现次数最多的数的出现次数，然后释放该文件，处理下一个文件，周而复始    
最后在100个最大值中选一个最大的作为出现次数最大值  
#### 存储形式
一个初始连续的内存空间n，每个数%n，等概率分配到不同的区间，每个地址后都跟着一串链表，长度为m  
m的值不能过大，否则哈希表查询时间不是O(1)，而是会接近O(N)  
当某一个数的链表超过m时，内存空间就扩容2倍，把原有的链表大概拆成两半，一半分配到新的内存空间上  
也可以采用开放寻址法，一个内存空间不够后，用链表的方式连接另外一整片空间  

#### 散列函数6种设计方法

```
取余法   折叠法      平方取中法
提取法   基数转换法   全域散列法
```

#### 3种哈希冲突解决办法

```
开放定址法   链接法   桶定址
```

