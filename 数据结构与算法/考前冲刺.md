## 1. STL容器有哪些？
```
vector：动态数组，支持快速随机访问和尾部插入。
list：双向链表，支持在任何位置高效插入和删除。
deque：双端队列，支持在两端高效插入和删除。
stack：栈，基于其他序列容器实现的后进先出（LIFO）结构。
queue：队列，基于其他序列容器实现的先进先出（FIFO）结构。
priority_queue：优先队列，基于其他序列容器实现的按优先级排序的队列。
set：有序集合，不允许重复元素。
map：有序键值对集合，不允许重复键。
multiset：允许重复元素的有序集合。
multimap：允许重复键的有序键值对集合。
unordered_set：无序集合，不允许重复元素。
unordered_map：无序键值对集合，不允许重复键。
unordered_multiset：允许重复元素的无序集合。
unordered_multimap：允许重复键的无序键值对集合。
```
## 2. O Ω θ表示法
```
Ω表示算法的渐近下界
O表示算法的渐近上界
θ表示夹在中间
```
## 3. 链表
### 3.1 单向链表
单链表有带/不带头结点两种写法；若带头结点，则头结点的data为null，next指向第一个节点
```C++
class Node {
public:
    int data;
    Node* next;
};
typedef Node* LinkList;  "对 Node* 取一个别名 LinkList"
```
#### 初始化一个单链表
```C++
"------不带头节点-------"
bool InitList0(LinkList &L){
    L = NULL;           "空表，暂时还没有任何节点"
    return true;
}
"------带头节点-------"
bool InitList(LinkList &L){
    L = (LinkList)malloc(sizeof(Node));  "分配一个头节点"
    if(L == NULL) 
        return false;                    "内存不足，分配失败"
    L->next = NULL;                      "头节点之后暂时没有节点"
    return true;
}
```
#### 建立单链表
```C++
"尾插法建立单链表(带头节点)"
void CreateListR(LinkList &L, int n){   "尾插入n个节点"
    L = (LinkList)malloc(sizeof(Node)); "分配一个头节点"
    L->next = NULL;                     "头节点的next指针指向NULL"
    LinkList cur = L;                     "cur指向尾节点(此时没有元素，头尾一样)"
    for(int i=0; i<n; i++){
        LinkList p = (LinkList)malloc(sizeof(Node));  "分配一个新节点"
        cin >> p->data;                 "输入元素值"
        cur->next = p;                    "将表尾终端节点的指针指向新节点p"
        cur = p;                          "类似cur指针，动态指向"
    }
    r->next = NULL;                     "表示当前链表结束"
}
"头插法建立单链表(带头节点)"
void CreateListF(LinkList &L, int n){
    L = (LinkList)malloc(sizeof(Node)); "分配一个头节点"
    L->next = NULL;                     "头节点的next指针指向NULL，防止原来头指针指向脏数据"
    for(int i=0; i<n; i++){
        LinkList p = (LinkList)malloc(sizeof(Node));  "分配一个新节点"
        cin >> p->data;                 "输入元素值"
        p->next = L->next;              "将新节点的next指针指向头节点的后继(新的第二个节点)"
        L->next = p;                    "头节点后继指向新插入的 第一个节点"
    }
}
```
#### 求单链表的长度(带头节点)    
```C++
"后加后结束(第一个节点 - 倒数第一个节点)"
int ListLengthB(LinkList L){
    int len = 0;
    LinkList p = L->next;             "p指向第一个节点node"
    while(p){                         "p不为空时，循环继续"
        ++len;
        p = p->next;
    }
    return len;
}
```
#### 3.1.1 插入
在第i个位置插入一个元素e(带头节点)
```C++
bool InsertNextNode(Node* p, int e);  "先声明一下"
bool ListInsert(LinkList &L, int i, int e){
    LinkList p = L;                   "p指向扫描到的节点，当前指向头节点"
    int j = 0;
    while(p && j < i-1) {             "寻找第i-2个节点"
        p = p->next;    "循环到最后的i-2位置后，进行最后一次赋值，让p指向第i-1个节点，即目标节点的前一个位置！"
        ++j;
    }
    return InsertNextNode(p, e);      "找到对应的p位置后，才能调用后插操作(malloc也在里面)"
}
```
后插操作：在p节点之后插入元素e
```C++
"从p节点开始，能访问后面的节点，但由于是单链表，不能访问前面的节点(除非传参插入头节点)"
bool InsertNextNode(Node *p, int e){
    if(p == NULL) 
        return false;
    Node *s = (Node *)malloc(sizeof(Node));
    if(s == NULL) 
        return false;    "内存满了，内存申请分配失败(如内存不足，极少发生，这两行代码可以不写)"
    s->data = e;
    s->next = p->next;   "此时的p->next是指向原来的下一个节点/null的"
    p->next = s;         "经典的插入“三操作”"
    return true;
}
```
前插操作：在p节点之前插入元素e
```C++
bool InsertPriorNode(Node *p, int e){
    if(p == NULL) 
        return false;
    Node *s = (Node *)malloc(sizeof(Node));
    if(s == NULL) 
        return false;    "内存满了，内存申请分配失败(如内存不足，极少发生，这两行代码可以不写)"
    "1、2步先后插"
    s->next = p->next;
    p->next = s;
    "3、4步再处理数据"
    s->data = p->data;  
    p->data = e;
    return true;
}
```
#### 3.1.2删除
```C++
"删除第i个元素(带头节点)"
bool ListDelete(LinkList &L, int i, int &e){
    if(i<1) 
        return false;
    LinkList p = L;
    int j = 0;
    while(p->next && j < i-1){      "寻找第i-1个节点，目的是让p能够指向第i-1个节点之后的第i个节点"
        p = p->next;
        ++j;
    }
    if(!(p->next) || j > i-1)       "链表的下一个节点为空或者j异常越界"
        return false;
    LinkList q = p->next;           "q指向第i个(要被删除的)节点"
    p->next = q->next;              "将p的后继不指向q,而是指向q的后继r"
    e = q->data;                    "将q的数据域赋值给e(存储被删除的元素数据)"
    free(q);                        "释放q所指向的内存,包括q的数据域和指针域"
    return true;
}
"删除指定节点p(给了节点位置，就不用重头开始遍历寻找了！)"
bool DeleteNode(Node *p){
    if(p == NULL) 
        return false;
    "实现逻辑：让p拿到的下一个节点q的数据后，其next直接指向q的下一个节点，最后把q删了就行"
    Node *q = p->next;              "q指向p的后继"
    p->data = q->data;              "将q的数据域赋值给p的数据域"
    p->next = q->next;              "将q的后继赋值给p的后继"
    free(q);                        "释放q所指向的内存，使被删去的元素的前一个元素p的next指针指向NULL"
    return true;
}
```
#### 3.1.3 查找
```C++
"按位查找-第i个节点(带头节点L)"
LinkList GetElem(LinkList L, int i, int &e){
    LinkList p = L->next;             "p指向第一个节点"
    int j = 1;                        "计数器"
    while(p && j < i){                "p不为空且计数器j还没有等于i时，循环继续"
        p = p->next;                  "p指向下一个节点"
        ++j;
    }
    if(!p || j > i)                   "第i个元素不存在(j == i 时，p指向NULL || j > i越界)"
        return NULL;
    e = p->data;                      "e是引用类型，将p的data赋值给e，e就存第i个元素的值"
    return p;                         "返回第i个元素的地址"
}
"按值查找-查找值为e的节点(带头节点)"
LinkList LocateElem(LinkList L, int e){
    LinkList p = L->next;             "p指向第一个节点"
    while(p != NULL && p->data != e)  "p不为空且p的data不等于e时，循环继续"
        p = p->next;
    if(p == NULL)                     "p为空，说明没有找到值为e的元素，返回NULL"
        return NULL;
    return p;                         "找到了，返回p"
}
```
### 3.2 双向链表
双链表一般带头节点，头节点的prev指向空，尾节点的next指向空
```C++
typedef struct Node{
    int data;
    Node *next;
    Node *prev;
}Node, *DLinkList;
```
初始化双链表
```C++
bool InitList(Node *&L){
    L = new Node;
    if (L == NULL){
        cout << "内存分配失败！" << endl;
        return false;
    }
    L->next = NULL;
    L->prev = NULL;
    return true;
}
```
插入节点
```C++
"后插入节点  (在p节点之后插入s节点)"
"p, p->next   -->    p, s, p->next"
bool InsertNextNode(Node *p, Node *s){
    if (p == NULL || s == NULL)
        return false;
    "s、p->next的互指"
    s->next = p->next;     "可能出现p->next==NULL的情况，即p之后没有节点，这时s插在末尾其next也是NULL，没毛病"
    if (p->next != NULL)
        p->next->prev = s;   "如果p原来后面还有节点，那么该节点的prev要指向插进来的s"
    "p、s的互指"
    p->next = s;
    s->prev = p;         
    return true;
}
```
```C++
"插入节点  (在p节点之前插入s节点)"
bool InsertPrevNode(Node *p, Node *s){
    if (p == NULL || s == NULL)
        return false;
    "s、p->prev的互指"
    s->prev = p->prev;       "(1)"
    if (p->prev != NULL)
        p->prev->next = s;   "(2)"
    "s、p的互指"
    s->next = p;             "(3)"
    p->prev = s;             "(4)"
    return true;
}
```
删除释放节点
```C++
"删除节点  (删除p节点之后的一个节点)"
bool DeleteNextNode(Node *p){
    if (p == NULL)           "传入的p节点不存在"
        return false;
    Node *q = p->next;       
    if (q == NULL)           "p节点之后没有节点，只能说删除了空气..."
        return false;
    p->next = q->next;       "(1)"
    "如果q->next == NULL, 说明删除后，p后面没有节点了；那么p->next指向NULL，不用执行下面if语句了"
    if (q->next != NULL)     "q节点之后还有节点"
        q->next->prev = p;   "(2)"
    delete q;
    return true;
}
"循环释放双链表"
void DestroyList(Node *L){
    Node *current = L->next;     "指向第一个数据节点"
    Node *temp;
    while (current != NULL) {
        temp = current->next;    "保存下一个节点的指针"
        DeleteNode(current);     "删除当前节点"
        current = temp;          "移动到下一个节点"
    }
    delete L;                    "释放头节点"
    L = NULL;                    "头指针置空"
}
```
遍历双链表
```C++
"后向遍历双链表（遍历头节点之后的）"
void ListTraverse(Node *L){
    Node *p = L->next;           "p指向第一个节点"
    while (p != NULL){
        cout << p->data << " ";
        p = p->next;             "最后一个指向null，不要访问就没什么问题"
    }
}
"前向遍历双链表"
void ListTraverseBack(Node *q){
    Node *p = q->prev;           "p为q的前驱节点(即前一个节点)"
    while (p->prev != NULL){     "遍历到头节点的->prev == NULL，循环结束"
        cout << p->data << " ";
        p = p->prev;             "最后一次时，p->prev为头指针，赋值给p"
    }
}
```
### 3.3 循环链表
```C++
"初始化循环单链表"
bool InitList(LinkList &L){
    L = new Node;
    if (L == NULL){
        cout << "内存分配失败！" << endl;
        return false;
    }
    L->next = L;    "头节点的next指向自己"
    return true;
}
"判断循环单链表是否为空"
bool Empty(LinkList L){
    if (L->next == L)  return true;
    else               return false;
}
"判断节点p是否为循环单链表的最后一个节点"
bool IsLast(LinkList L, Node *p){
    if (p->next == L)  return true;
    else               return false;
}
```

## 4. 栈和队列
### 4.1 栈
```C++
// 声明一个栈
stack<int> myStack;
// 入栈操作
myStack.push(1);
myStack.push(2);
myStack.push(3);
// 获取栈顶元素
cout << "Top element: " << myStack.top() << endl;
// 出栈操作
myStack.pop();
// 判断栈是否为空
if (myStack.empty()) {
    cout << "Stack is empty." << endl;
} else {
    cout << "Stack is not empty." << endl;
}
```
### 4.2 队列
```C++
// 声明一个队列
queue<int> myQueue;
// 入队操作
myQueue.push(1);
myQueue.push(2);
myQueue.push(3);
// 获取队首元素
cout << "Front element: " << myQueue.front() << endl;
// 出队操作
myQueue.pop();
// 判断队列是否为空
if (myQueue.empty()) {
    cout << "Queue is empty." << endl;
} else {
    cout << "Queue is not empty." << endl;
}
```
### 用list实现栈和队列
```C++
class Stack {
private:
    list<int> myStack;
public:
    void push(int value) {
        myStack.push_back(value);
    }
    void pop() {
        if (!myStack.empty()) {
            myStack.pop_back();
        }
    }
    int top() {
        if (!myStack.empty()) {
            return myStack.back();
        }
        return -1;
    }
    bool empty() {
        return myStack.empty();
    }
};
```
```C++
class Queue {
private:
    list<int> myQueue;
public:
    void enqueue(int value) {
        myQueue.push_back(value);
    }
    void dequeue() {
        if (!myQueue.empty()) {
            myQueue.pop_front();
        }
    }
    int front() {
        if (!myQueue.empty()) {
            return myQueue.front();
        }
        return -1;
    }
    bool empty() {
        return myQueue.empty();
    }
};
```

## 5. 递归
### 5.1 递归定义
分两部分：1是锚或基例，产生基本元素或对象
2是根据这些基本元素或对象产生新的规则或对象并反复使用，
### 5.2 函数调用和递归实现
栈的叠加，每一层递归调用就进栈，递归结束后的回溯会陆续按相反的顺序出栈
### 5.3 分析递归调用（代码）
```
x4 = x·x3 = x·x·x2 = x·x·x·x
func(3) 
  func(2) 
    func(1) 
    1
  2
3
```
### 5.4 回溯 - 八皇后问题（代码）
```C++
class ChessBoard {
public:
    ChessBoard();    // 8 x 8 chessboard;
    ChessBoard(int); // n x n chessboard;
    void findSolutions();
private:
    const bool available;
    const int squares, norm;
    bool *column, *leftDiagonal, *rightDiagonal;
    int  *positionInRow, howMany;
    void putQueen(int);
    void printBoard(ostream&);
    void initBoard();
};

ChessBoard::ChessBoard() : available(true), squares(8), norm(squares-1) {
    initBoard();
}
ChessBoard::ChessBoard(int n) : available(true), squares(n), norm(squares-1) {
    initBoard();
}
void ChessBoard::initBoard() {
    register int i;
    column = new bool[squares];
    positionInRow = new int[squares];
    leftDiagonal  = new bool[squares*2 - 1]; // max(row+col) = squares*2 - 2
    rightDiagonal = new bool[squares*2 - 1]; 
    // min(row-col) = -(squares-1)  min(row-col+norm) = 0   max(row-col+norm) = squares*2 - 2
    for (i = 0; i < squares; i++)
        positionInRow[i] = -1;   // 当前第i行还没放皇后
    for (i = 0; i < squares; i++)
        column[i] = available;
    for (i = 0; i < squares*2 - 1; i++)
        leftDiagonal[i] = rightDiagonal[i] = available;
    howMany = 0;
}
void ChessBoard::printBoard(ostream& out) {
    // . . . .
}
void ChessBoard::putQueen(int row) {
    for (int col = 0; col < squares; col++) {
        // 如果当前位置可放置皇后
        if (column[col] == available &&
            leftDiagonal[row + col] == available &&
            rightDiagonal[row - col + norm] == available) {
            // 将皇后放置在当前位置
            positionInRow[row] = col;   // 第row行的皇后放在第col列
            // 记录这个positionInRow一维数组相当于记录了一种情况下n皇后的摆法
            column[col] = !available;
            leftDiagonal[row + col] = !available;
            rightDiagonal[row - col + norm] = !available;

            if (row < squares - 1)
                // 递归调用，尝试在下一行放置皇后
                putQueen(row + 1);
            else
                // 如果已经放置了最后一行的皇后，打印棋盘状态
                printBoard(cout);

            // 回溯，将皇后拿掉，以便尝试其他位置
            column[col] = available;
            leftDiagonal[row + col] = available;
            rightDiagonal[row - col + norm] = available;
        }
    }
}
void ChessBoard::findSolutions() {
    putQueen(0);
    cout << howMany << " solutions found.\n";
}

int main() {
    ChessBoard board(4);
    board.findSolutions();
    return 0;
}
```
## 6. 二叉树（第7章多叉树不考）
### 6.1 树定义
只有一个根节点，由节点和弧组成
空结构是空树，不相交的树，它们的根作为子节点也构成一棵树
只有通过上面那句话产生的数据结构才是树
### 6.2 二叉树的实现
```C++
// 定义树节点类
class TreeNode {
public:
    int data;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}
};
// 定义搜索二叉树类
class BinarySearchTree {
private:
    TreeNode* root;
    // 插入节点的辅助函数
    TreeNode* insert(TreeNode* node, int val) {
        if (node == nullptr) {
            return new TreeNode(val);
        }
        if (val < node->data) {
            node->left = insert(node->left, val);
        } else if (val > node->data) {
            node->right = insert(node->right, val);
        }
        return node;
    }
    // 搜索节点的辅助函数
    bool search(TreeNode* node, int val) {
        if (node == nullptr) {
            return false;
        }
        if (val == node->data) {
            return true;
        } else if (val < node->data) {
            return search(node->left, val);
        } else {
            return search(node->right, val);
        }
    }
    // 中序遍历的辅助函数
    void inorderTraversal(TreeNode* node) {
        if (node != nullptr) {
            inorderTraversal(node->left);
            cout << node->data << " ";
            inorderTraversal(node->right);
        }
    }
public:
    BinarySearchTree() : root(nullptr) {}
    // 插入节点
    void insert(int val) {
        root = insert(root, val);
    }
    // 搜索节点
    bool search(int val) {
        return search(root, val);
    }
    // 中序遍历
    void inorderTraversal() {
        inorderTraversal(root);
        cout << endl;
    }
};
```
### 6.3 二叉树的查找
```C++
template<class T>
T* BST<T>::search(BSTNode<T>* p, const T& el) const{
  while(p != nullptr){
    if(el == p->el)
      return &p->el;
    else if(el < p->el)
      p = p->left;
    else p = p->right;
  }
}
```
### 6.4 树的深度/前中后+广度遍历
```C++
void process(Node* head) {
  while (head != NULL){
    head->data = 1;
    "cout写在这里打印是先序遍历"
    process(head->left);
    "cout写在这里打印是先序遍历"
    process(head->right);
    "cout写在这里打印是先序遍历"
  }
}
```
栈实现深搜
```C++
void frontPrint(Node* head){
  if (head != NULL){
    stack<Node*>stack;       "创建一个栈"
    stack.push(head);        "先把头节点压入栈中"
    while (!stack.empty()){  "如果栈中有元素，就执行while中的语句"
      "先打印，并弹出栈顶元素，最后先右后左压栈(如果有的话)"
      cout << stack.top();
      stack.pop();
      if (head->right != NULL){
          stack.push(head->right);
      }
      if (head->left != NULL){
          stack.push(head->left);
      }     "left后压栈，先出栈，实现先序遍历"
    }
  }
}
```
队列实现广搜
```C++
void width(Node* head){
	if (head == NULL)   return;
	queue<Node*> queue;   "准备一个队列"
	queue.push(head);     "放入头节点"
	while (!queue.empty()){      "如果队列不为空就循环"
		head = queue.front();    "当前节点指向新弹出的元素"
		cout << head << " ";     "先打印，再弹出队头元素"
		queue.pop();
		"再让该元素的 先左后右 节点 插入队尾"
		if(head->left != NULL)
			queue.push(head->left);
		if(head->right != NULL)
			queue.push(head->right);
	}
}
```
### 6.5 堆（定义，判断，建立，恢复堆）
特殊的平衡二叉树，父亲较大，最后一层的叶子节点靠最左侧位置
```C++
void swap(int* arr, int l, int r){
    int tmp = arr[l];
    arr[l] = arr[r];
    arr[r] = tmp;
}
"1.构建大根堆"（建立堆）
void heapinsert(int* arr, int index){
	"如果新插入的数比它的父节点大，则要swap交换"
	while (arr[index] > arr[(index - 1) / 2]){
		swap(arr, index, (index - 1) / 2);
		"index跟着插入数走，插入的数上位，索引跟着上"
		index = (index - 1) / 2;
	}
}
void heapInsert(int* arr, int len){
	for (int i = len - 1; i >= 0; i--){
		heapify(arr, i, len);
	}
}
"2.取出最大值后再排序"（恢复堆）
void heapify(int* arr, int index, int heapsize){
	int left = index * 2 + 1;
	while (left < heapsize){      "下方还有孩子的时候"
		"两个孩子(前提得有右孩子)中，谁的值大，就把下标给largest"
		int largest = left + 1 < heapsize && arr[left + 1] > arr[left] ? left + 1 : left;
		"父和较大的孩子间，谁的值大，就把下标给largest"
		largest = arr[largest] > arr[index] ? largest : index;
		if (largest == index)
			break;        "父节点较大，子篡位不成，停止了"
		swap(arr, largest, index);   "子节点较大，才执行这段代码，篡位成功，让位置交换"
		index = largest;             "index永远指向该父节点的位置，父节点让位到子节点的位置上"
		left = index * 2 + 1;        "新的子节点位置（父节点跟原来此位置的子节点作比较）"
	}
}
"3.堆排序"
void heapSort(int* arr, int len){
	if (arr == NULL || len < 2)
		return;
	"3.1 先构建大根堆，完成后就已知arr最大值(根节点的value)"
	"(1)传统写法"
	for (int i = 0; i < len; i++){   "O(N)"
		heapinsert(arr, i);          "O(logN)"
	}                                "O(N*logN)"
	"(2)进阶写法，且更常用"
	heapInsert(arr, len);            "O(N)"

	"3.2 取出根节点这个最大值，与末尾节点做交换，然后移除末尾(最大值)元素"
        "末尾节点到根节点位置后就heapify，再去重新进行大根堆的构建"
	int heapsize = len;
	swap(arr, 0, --heapsize);        "每次都交换后，堆数组长度--，让末尾那些排好序的数不被影响"
	while (heapsize > 0){            "O(N)   数组长度为0，才退出循环"
		heapify(arr, 0, heapsize);   "O(logN)"
		swap(arr, 0, --heapsize);    "O(1)"
	}                                "O(N*logN*1) == O(N*logN)"
}
```
## 8. 图
### 8.1 图的定义表示
#### 定义
非空点集和可空边集组成，每条边是两个顶点的集合
#### 表示
1. 邻接表
```C++
A     B   C
B     A
C     A   B   D
D     B   C
// 链表表示，from有两个指针，指右和下
// 或者数组+链表，数组每个元素都是from开始的链表
[Node1(from_A) -> Node2(to) -> Node3(to) -> Node4(to),
Node1(from_B) -> Node2(to) -> Node3(to) -> Node4(to)]
```
2. 邻接矩阵
```
weight(w)      ∞(表示没有直接相邻)
      A     B     C     D
A     w     w     w     ∞
B     ∞     w     w     w
C     w     w     ∞     ∞
D     ∞     ∞     w     w
```
3. 关联矩阵
所有点为最左列，所有边为最上行
```
     AB   AC   BC   BD
A     1    1    0    0
B     1    0    1    1
C     0    1    1    0
D     0    0    0    1
```
### 8.2 图的深度、广度优先遍历（伪代码）
#### 宽度优先遍历(BFS)
类似树，某一个节点遍历后，遍历与之相邻的**所有**节点作为第二层，再遍历与第二次所有节点相邻的点作为第三层（不包括第一层的根节点）...  
```C++
void BFS(Node* node) {
    if (node == nullptr)   return;
    queue<Node*> q;
    unordered_set<Node*> visited;
    q.push(node);
    visited.insert(node);
    while (!q.empty()) {
        Node* cur = q.front();
        q.pop();
        cout << cur->value << endl;     // 打印行为可以换成其他处理行为
        for (Node* next : cur->nexts) {
            if (visited.find(next) == visited.end()) {  // 还没visit(防止往上一层找邻居)
                visited.insert(next);   // 加入当前cur->next的所有节点
                q.push(next);
            }
        }
    }
}
```
#### 深度优先遍历(DFS)
类似树，某一个节点遍历后，遍历与之相邻的**一个**节点作为第二层，然后直接break，去找该节点的第三层，其他过程类似树的深度优先遍历...  
```C++
void dfs(Node* node) {
    if (node == nullptr)   return;    
    stack<Node*> stack;
    unordered_set<Node*> visited;
    stack.push(node);
    visited.insert(node);
    cout << node->value << endl;  // insert后就打印，确保是先序遍历
    while (!stack.empty()) {
        Node* cur = stack.top();
        stack.pop();
        for (Node* next : cur->nexts) {
            if (visited.find(next) == visited.end()) {
                stack.push(cur);
                stack.push(next);  // 这条路一直走，其他不管
                visited.insert(next);
                cout << next->value << endl;  // 先序遍历打印的位置
                break;   // break，不走宽度走深度
            }
        }
    }
}
```
递归版本
```C++
// 递归实现的深度优先搜索辅助函数
void DFS(int v, vector<bool>& visited) {
    visited[v] = true;
    cout << v << " ";
    // 对所有邻接节点递归调用DFSUtil
    for (int neighbor : adj[v]) {
        if (!visited[neighbor]) {
            DFS(neighbor, visited);
        }
    }
}
```
### 8.3 最短路（要会操作）
不能有权值为负的边
规定一个出发点，求出该点到其他点的最短距离各是多少（对于不可达的点默认距离无穷大）  
实现： 初始化到自己为0，到别的点距离正无穷
      自己出发找到最小边，找到的路径比原来小就重写，比较完所有路径后锁死当前点，下一个点为当前点最小边的另一端  
      （感觉其实当前点出发只能找到其他节点的新的最小值，自己的路径已经固定锁死了...）  
      下一个点依次循环上述过程，在这之前要记好出发点连到自己的最短距离
```C++
unordered_map<Node*, int> dijkstra1(Node* head) {
    unordered_map<Node*, int> distanceMap;
    distanceMap[head] = 0;
    unordered_set<Node*> selectedNodes;
    Node* minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
    while (minNode != nullptr) {    // 最后所有节点都处理完了/被锁了，退出循环结束任务
        int distance = distanceMap[minNode];
        for (const Edge& edge : minNode->edges) {
            Node* toNode = edge.to;
            if (distanceMap.find(toNode) == distanceMap.end()) {  // distanceMap要记录
                distanceMap[toNode] = distance + edge.weight;  
            else             // distanceMap要更新
                distanceMap[edge.to] = min(distanceMap[toNode], distance + edge.weight);                                               
        }
        selectedNodes.insert(minNode);   // 处理完了到这个节点的mindistance，把它锁了(selected)！
        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
        // 重新在没被锁的节点中，找到起始点到其距离最短的点
    }
    return distanceMap;   // 把到<各个点,最小距离>的这个map返回
}
Node* getMinDistanceAndUnselectedNode(unordered_map<Node*, int>& distanceMap,
                                      unordered_set<Node*>& touchedNodes) {
    Node* minNode = nullptr;
    int minDistance = numeric_limits<int>::max();
    for (const auto& entry : distanceMap) {
        Node* node = entry.first;
        int distance = entry.second;
        if (touchedNodes.find(node) == touchedNodes.end() && distance < minDistance) {
            minNode = node;             // 不能被锁，距离更小
            minDistance = distance;     // 更新节点及其距离
        }
    }
    return minNode;
}
```
伪代码
```
Dijkstra算法（从头节点head开始）：
  初始化距离映射 distanceMap，将head到自身的距离设置为0
  初始化已选节点集合 selectedNodes 为空集合
  从distanceMap中获取距离最小且未被选择的节点 minNode
  while minNode 不为空:
    获取 minNode 到 head 的距离 distance
    遍历 minNode 的所有边：
      获取边的目标节点 toNode
      如果 distanceMap 中未记录 toNode：
        将 distance + 边的权重 记录到 distanceMap 中（需要记录）
      否则：
        更新 distanceMap[toNode] 为 distance + 边的权重 的最小值（需要更新）
    将 minNode 加入已选节点集合 selectedNodes
    重新获取未被选择的节点中，距离 head 最短的节点 minNode
  返回 distanceMap（记录了从head到各个节点的最小距离）
```
### 8.4 最小生成树（K算法）
最小生成树：所有点连通，但权值和最小
```C++
class MySets {
public:
    unordered_map<Node*, vector<Node*>> setMap;  // 拿到一个点所对应的点集
    MySets(const vector<Node*>& nodes) {
        for (Node* cur : nodes) {
            vector<Node*> set;
            set.push_back(cur);      // 刚开始每个点都自成一个点集
            setMap[cur] = set;
        }
    }
    bool isSameSet(Node* from, Node* to) {
        vector<Node*>& fromSet = setMap[from];
        vector<Node*>& toSet = setMap[to];
        return &fromSet == &toSet;   // 看两个点所在的点集，地址是否相同
    }
    void unionSets(Node* from, Node* to) {
        vector<Node*>& fromSet = setMap[from];
        vector<Node*>& toSet = setMap[to];
        for (Node* toNode : toSet) {
            fromSet.push_back(toNode);  // 两点连通，集合合并在fromSet里
            setMap[toNode] = fromSet;   // 普通相连没有考虑树高，简单粗暴
        }
    }
};
```
K算法
```C++
unordered_set<Edge> kruskalMST(Graph* graph) {
    UnionFind unionFind;
    unionFind.makeSet(graph->nodes);    // 1.对应MySets
    priority_queue<Edge, vector<Edge>, EdgeComparator> priorityQueue;
    for (Edge edge : graph->edges) {
        priorityQueue.push(edge);       // 边升序排序
    }
    unordered_set<Edge> result;         // 边集(防止重算)
    while (!priorityQueue.empty()) {
        Edge edge = priorityQueue.top();
        priorityQueue.pop();
        if (!unionFind.isSameSet(edge.from, edge.to)) {
            result.insert(edge);        // 2.之前不在同个集合里/不构成环，就加上这条边
            unionFind.unionSets(edge.from, edge.to);  // 3.并查集里设置好
        }
    }
    return result;
}
```
多源最短路Floyd算法
```C++
const int INF = 1e9;  // 无穷大表示两节点之间没有直接连接的路径
// graph是原邻接矩阵，numNodes是节点个数，path是记录两点间的中间点
void floyd(vector<vector<int>>& graph, int numNodes, vector<vector<int>>& path) {
    vector<vector<int>>& tmp;
    // 初始化
    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            tmp[i][j] = graph[i][j];  // 初始化把原矩阵搬过来
            path[i][j] = INF;  // 初始化距离无穷大
        }
    }
    // 最外层是每个节点作为中间点
    for (int k = 0; k < numNodes; ++k) {
        // 内两层是邻接矩阵中，每条边对应的两个点
        for (int i = 0; i < numNodes; ++i) {
            for (int j = 0; j < numNodes; ++j) {
                if (tmp[i][k] != INF && tmp[k][j] != INF && tmp[i][k] + tmp[k][j] < tmp[i][j]) {
                    tmp[i][j] = tmp[i][k] + tmp[k][j];
                    path[i][j] = k;   // 这个最短路径的中间节点是k
                }
            }
        }
    }
}
```
## 9. 排序
### 9.1 冒泡排序
```C++
void bubbleSort(int* arr, int len){
  for(int i = 0; i < len -1; i++){
    for(int j = 0; j < len - i - 1; j++){
      if(arr[j] > arr[j+1]){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
    }
  }
}
```
### 9.2 选择排序
```C++
void selectSort(int* arr, int len){
  for(int i = 0; i < len - 1; i++){
    int min = arr[i];
    for(int j = i+1; j < len; j++){
      min = arr[j] < arr[min] ? arr[j] : arr[min];
    }
    if(arr[i] > arr[min]){
      int tmp = arr[i];
      arr[i] = arr[min];
      arr[min] = tmp;
    }
  }
}
```
### 9.3 插入排序
```C++
void insertSort(int* arr, int len){
  for(int i = 1; i < len; i++){
    for(int j = i-1; j >= 0 && arr[j] > arr[j+1]; j--){
      int tmp = arr[j];
      arr[j] = arr[j+1];
      arr[j+1] = tmp;
    }
  }
}
```
### 9.4 归并排序
```C++
void Merge(int* arr, int l, int m, int r)  
"l,m+1分别是两个部分的开头，r是第二个部分的末尾"
{
	int len = r - l + 1;  "子过程两部分的总长度"
	"定义左右指针"
	int p1 = l;
	int p2 = m + 1;
    "分配大小为 len * sizeof(int) 字节的内存块"
	int* tmparr = new int [len];
	for (int i = 0; i < len; i++){
		if (p1 <= m && p2 <= r){
			"都没越界，若左边小，取出来给tmparr[i]，指针右移(运算后再移动，即后置++)，若右边小同理"
			tmparr[i] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}else if (p2 == r+1){
			"右边越界，显然右边都放置好了，现在把左边全部放入tmparr就行"
			tmparr[i] = arr[p1++];  "放完后再指针右移，然后进入下一个循环"
		}else if (p1 == m+1){
			"只剩左边越界这种情况了，那就把右边全部放入tmparr就行"
			tmparr[i] = arr[p2++];
		}
	}
	"把tmparr这个排好序的数组覆盖到原来的数组上面，并释放tmparr的内存"
}
"递归 + merge = （左右均无序的，指定范围的）归并排序， 通过递归，让最小单位的元素依次排序"
void process(int* arr, int l, int r){
    if (l == r)
        return;   
    int mid = l + ((r - l) >> 1);     "右移后，mid是中间偏左的那个数"
    process(arr, l, mid);
    process(arr, mid + 1, r);
    merge(arr, l, mid, r);            "这里merge的位置相当于后序遍历的位置！"
}
"mergeSort整个数组的归并排序"
void mergeSort(int* arr, int len){
    if (arr == NULL || len < 2)
        return;  
    process(arr, 0, len - 1); "指定范围是整个数组的递归+归并排序"
}
```
### 9.5 快速排序
```C++
"交换函数"
void swap(int* arr, int& l, int& r){
    int tmp = arr[l];
    arr[l] = arr[r];
    arr[r] = tmp;
}
"处理arr[l...r]的函数，将其根据arr[r]=p, 划分为 <p =p >p 三部分，partition是划分的意思"
int* partition(int* arr, int l, int r){    "r 是划分值的位置，不是右指针！"
	"初始化<区域(即less区域)右边界，>区域more的左边界"
	while (当前位置 < more区域的最左侧){   "l表示当前数的位置， arr[r]是划分值"
	"l指向所有less和=区域，所以会与more区域相遇(而如果中间区域有值，less 恒< more)"
		"当前数小于划分值"
			"让当前数交换到less的下一个位置(less++)，然后less左区域扩容"
		"当前数大于划分值"
			"让当前数交换到more的下一个位置(more--)，然后more右区域扩容"
		"等于，不交换，指针右移，跳过该值"
	}
	"最右侧的划分值要回到原来的中间=的区域"
	"返回长度为2的数组，[0]指向"="区域最左侧，[1]指向"="区域最右侧"
}
"局部快速排序"
void quicksort(int* arr, int l, int r, int randomValue){
	if (l < r) {
		"随机选个位置，让这个随机位置指向的值与最右侧的值交换"
		int* p = partition(arr, l, r);  "此时的r已经被换为随机值了，以其作划分来玩partition"
		"partition划分为三部分后，返回=区域的两侧位置，即< = >三部分的边界"
		quicksort(arr, l, p[0] - 1, randomValue);   "<区域 做递归快排"
		quicksort(arr, p[1] + 1, r, randomValue);   ">区域 做递归快排"
	}
}
"整体快速排序"
void quickSort(int* arr ,int len, int randomValue){
	if (arr == NULL || len < 2)
		return;
	"数组双指针，指向最左侧和最右侧"
	quicksort(arr, 0, len - 1, randomValue);
}
```
### 9.6 堆排序
```C++
void swap(int* arr, int l, int r){
    int tmp = arr[l];
    arr[l] = arr[r];
    arr[r] = tmp;
}
"1.构建大根堆（从无到有）"
void heapinsert(int* arr, int index){
	while (如果新插入的数比它的父节点大){
        swap交换，新插入的节点到它父节点的位置
        index指针跟上，进行下一轮while判断
	}
}
"已有数组通过排序得到堆的形式"
void heapInsert(int* arr, int len){
	for (int i = len - 1; i >= 0; i--){
        倒序遍历，每个节点向下比较并更改位置
		heapify(arr, i, len);
	}
}
"2.取出最大值后，新的根节点向下移动进行恢复堆"
void heapify(int* arr, int index, int heapsize){
	int left = index * 2 + 1;
	while (left < heapsize){      "下方还有孩子的时候"
		"两个孩子(前提得有右孩子)中，谁的值大，就把下标给largest"
		int largest = left + 1 < heapsize && arr[left + 1] > arr[left] ? left + 1 : left;
		"父和较大的孩子间，谁的值大，就把下标给largest"
		largest = arr[largest] > arr[index] ? largest : index;
		if (largest == index)
			break;        "父节点较大，子篡位不成，停止了"
		swap(arr, largest, index);   "子节点较大，才执行这段代码，篡位成功，让位置交换"
		index = largest;             "index永远指向该父节点的位置，父节点让位到子节点的位置上"
		left = index * 2 + 1;        "新的子节点位置（父节点跟原来此位置的子节点作比较）"
	}
}
"3.堆排序"
void heapSort(int* arr, int len){
	if (arr == NULL || len < 2)
		return;
	"3.1 先构建大根堆，完成后就已知arr最大值(根节点的value)"
	heapInsert(arr, len);            "O(N)"
	"3.2 取出根节点这个最大值，与末尾节点做交换，然后移除末尾(最大值)元素，最大值元素放到arr末尾已经排好序了，不需要再到堆中"
        "末尾节点到根节点位置后就heapify，再去重新进行大根堆的构建"
	int heapsize = len;
	swap(arr, 0, --heapsize);        "每次都交换后，堆数组长度--，让末尾那些排好序的数不被影响"
	while (heapsize > 0){            "O(N)   数组长度为0，才退出循环"
		heapify(arr, 0, heapsize);   "O(logN)"
		swap(arr, 0, --heapsize);    "O(1)"
	}                                "O(N*logN*1) == O(N*logN)"
}
```

## 10. 散列
### 10.1 散列函数6种设计方法
```
取余法   折叠法      平方取中法
提取法   基数转换法   全域散列法
```
### 10.2 3种哈希冲突解决办法
```
开放定址法   链接法   桶定址
```

## 11. 数据压缩
### 11.1 haffman编码（考计算平均码长）
最后一层才有权值，其与深度相乘后累加
