# 四、进程同步

原书上2.4小节

## 4.1 进程同步的概念

把异步环境下的一组并发进程因直接制约而互相发送消息、互相合作、互相等待，使得各进程按一定的速度执行的过程，称为进程同步

协作进程：具有同步关系的一组并发进程

<span style="font-size:1.4rem; background: rgb(255,150,150);">**进程的两类制约关系（互斥关系、同步关系）**</span>

**间接相互制约关系（互斥关系）** 比如像打印机、磁带机这样的系统资源，必须保证多个进程对其只能进行互斥访问

**直接相互制约关系（同步关系）** 为了完成某个任务而多个进程协作

### 进程同步问题：生产者-消费者问题

生产者-消费者之间有n个缓冲区的缓冲池

尽管所有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步

不允许消费者进程到一个空缓冲区中去取产品

不允许生产者进程向一个已装满产品的缓冲区投放产品

### 临界区

临界区的概念：每个进程中访问临界资源的那段代码称为临界区（critical section）

临界区的意义：若能保证各进程互斥地进入自己的临界区，便可实现各进程对临界资源的互斥访问

<span style="font-size:1.4rem; background: rgb(255,150,150);">**临界资源和临界区的概念**</span>

<span style="font-size:1.4rem; background: rgb(255,150,150);">**需要采用互斥方式使用的的资源被称为临界资源，访问临界资源的那段代码称为临界区**</span>

### 同步机制

<span style="font-size:1.4rem; background: rgb(255,150,150);">**同步机制应遵循的准则**</span>

- <span style="font-size:1.4rem; background: rgb(255,150,150);">**空闲让进**</span>

- <span style="font-size:1.4rem; background: rgb(255,150,150);">**忙则等待(有线程使用临界区资源就等待)**</span>

- <span style="font-size:1.4rem; background: rgb(255,150,150);">**有限等待(不能死等)**</span>
- <span style="font-size:1.4rem; background: rgb(255,150,150);">**让权等待(不能进入临界区的进程要释放CPU)**</span>



## 4.2 软件同步机制

有点过时，现在计算机可能不支持

代码思路就是flag[i]  flag[j] 表示进程pi pj是否在临界区

```java
do{
    flag[i] = true;  // i想进厕所（比喻）
    turn = j;        // 但i谦让给j了
    while (flag[j] && turn == j) ;  // 空语句，表示j在临界区里面占用资源的话，i就死等
    // i 进入临界区，使用资源，直到使用完毕
    // 使用ing...
    flag[i] = false;
    // i 进入剩余区
    // 可能其他操作...
    // 等到i又想进厕所了，返回到最上方重新循环
} while (1);
```



## 4.3 硬件同步机制

关闭中断，相当于执行原子操作，底层不会被拆分，也就不会出现不同步问题

循环中不断改变锁的状态



## 4.4 信号量机制

<span style="font-size:1.4rem; background: rgb(255,245,100);">**信号量同步机制中信号量代表的物理意义（下方例题）**</span>

1、若信号量的初值为2，当前值为-1，则表示有多少个等待进程？请分析。 

> 信号量初值为2，表示资源总量为2
> 当前值为-1，表示目前2个资源已经分配完毕，且有1个进程在等待资源

2、有m个进程共享同一临界资源，若使用信号量机制实现对某个临界资源的互斥访问， 请求出信号量的变化范围。

> 临界资源，信号量初始值为1
> 每当有1个进程申请访问该临界资源，信号量-1 
> 最多同时有m个进程申请访问该临界资源，所以信号量最小为1-m
> 信号量变化范围：1-m至1

### 整型信号量

用一个整数型的变量作为信号量，用来表示系统中某种资源的数量

例:  某计算机系统中有一台打印机…

```c++
int S = 1;  // 初始化整型信号量s,表示当前系统中可用的打印机资源数
void wait (int S) {   // wait 原语,相当于“进入区”    P(S)
	while (S <= 0);   // 如果资源数不够,就一直循环等待
	S = S - 1;        // 如果资源数够,则占用一个资源 
}
void signal (int S){  // signal 原语,相当于“退出区”  V(S)
	S = S + 1;        //使用完资源后,在退出区释放资源
}
```

进程P0:

```c++
wait(S);          // 进入区,申请资源
使用打印机资源 ...  // 临界区,访问资源
signal(S);        // 退出区,释放资源
```
进程P1:

```c++
wait(S);          // 进入区,申请资源
使用打印机资源 ...  // 临界区,访问资源
signal(S);        // 退出区,释放资源
```
进程Pn ...

优点：检查和上锁一气呵成

缺点：不满足让权等待，等不到资源会死等

### 记录型信号量

在整型信号量记录当前资源数量的基础上，类似多了个缓冲队列区

等不到资源不要死等，进阻塞队列

如果释放资源后发现有进程在阻塞队列而刚好这个进程需要这个资源，那就唤醒它

由于阻塞态的进程会**放弃对CPU执行权**，因此实现了**让权等待**！

```c++
// 记录型信号量的定义
typedef struct {
    int value;            // 剩余资源数
    Struct process *L;    // 等待队列
} semaphore;
// 某进程需要使用资源时，通过 wait 原语申请
void wait (semaphore S) {
	S.value--;
    if (S.value < 0) {
    	block (S.L);    // 资源不够，进阻塞队列
    }
}
// 进程使用完资源后，通过 signal 原语释放
void signal (semaphore S) {
	S.value++;
    if (S.value <= 0) { // 还有等待资源的人
    	wakeup(S.L);    // 有进程申请资源，唤醒阻塞队列的队头进程
    }
}
```

> tips: P(S)  V(S) 中的S，默认为记录型信号量

### And型信号量

一个进程开始前要先说好要什么资源，先全部拿到，等到进程结束再统一释放

如果一开始无法全部拿到，那就进入对应资源的阻塞队列，等到所有资源都可用时，才从阻塞队列出来，进程可用

### 信号量集

And信号量的扩充，对信号量进行 P V 原语操作是**批量**的

当申请的资源数量 >= 下限值时，才会进行 P V 操作，否则不予处理



## 4.5 管理机制

相比自备同步操作wait、signal的大量分散在不同进程中，管理机制能够有效集中管理

引入条件变量，相比于普通的wait、signal更方便标识状态和管理



## 4.6 经典进程的同步问题

### 生产者-消费者问题

记录型信号量解决法：

就是对缓冲区的资源数量进行++, -- 操作，每次生产和消费都先判断再进行加减操作而已！

其他and信号量、管程解法的思想类似，不再赘述，还不如去看阿玮...



### 哲学家进餐问题

n个哲学家，n只筷子，交错在圆桌上排开，若都同时拿起左/右边筷子，每人都得到一只筷子，造成死锁

解决：最多允许n-1个人同时拿筷子，能同时拿到两只筷子才允许他吃饭(允许进程运行)，否则要等待别人吃完把筷子放下

信号量实现：n只筷子用n个信号量表示



### 读者-写者问题

两组并发读写进程，同一时刻允许多读，不允许读写、多写

读者优先：优先唤醒读者        写者优先：优先唤醒写者

记录型信号量、信号量集解决问题



