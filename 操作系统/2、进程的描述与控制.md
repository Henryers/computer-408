# 二、进程的描述与控制



## 2.1 前驱图和程序执行

### 前驱图

<span style="font-size:1.4rem; background: rgb(255,245,100);">**前驱图的画法（作业第一题）**</span>

**有向无环图**，看似有环，实则被有向限制，不可能回到原来的位置

**初始节点**   无前驱的节点

**终止节点**   无后继的节点

**特征**    顺序性  封闭性  可再现性

### 程序并发执行

在系统中引入了多道程序技术，使程序或程序段间能并发执行

但是**只有不存在前趋关系的程序才有可能并发执行**

**特征**   间断性   失去封闭性   不可再现性

不可再现性：体现为共享资源时，不同程序抢占使用的时间不同导致资源的状态也不同，比如同个变量在不同时间内被运算并重新赋值

解决方案：不要共用资源，或先规定顺序，不要没执行完一个功能就被别人抢了



## 2.2 进程的描述

只有并发而没有进程，则会引发上述提到的 **间断性   失去封闭性   不可再现性** 等缺点

为了使程序可以并发执行，并且可以对并发执行的程序加以描述和控制，引入进程这一概念

定义：进程是程序的执行过程，是系统进行资源分配和调度的一个独立单位



### 进程控制块PCB

为了使参与并发执行的每个程序（含数据）都能独立地运行，在OS中必须为之配置一个专门的数据结构，称之为进程控制块（PCB）

如果没这个PCB，那么程序的并发会互相影响，没有一个框给它圈住



### 进程特征

<span style="font-size:1.4rem; background: rgb(255,150,150);">**进程的四个基本特征**</span>

<span style="font-size:1.4rem; background: rgb(255,150,150);">**动态性、并发性、独立性、异步性**</span>



### 进程状态

**就绪、执行、阻塞**

阻塞指请求资源此时正被其他程序所使用

**激活与挂起**

挂起指将进程变成静止状态： 活动就绪/阻塞  ->  静止就绪/阻塞

激活就是将静止变活动

<span style="font-size:1.4rem; background: rgb(255,150,150);">**进程的三个基本状态，及其转换关系（如下图）**</span>

![image-20240619154135376](C:\Users\cyhrecold\AppData\Roaming\Typora\typora-user-images\image-20240619154135376.png)



### PCB的作用

>作为独立运行基本单位的标志
>能实现间断性运行方式             （数据存在PCB中）
>提供进程管理所需要的信息      （PCB有对应内存地址）
>提供进程调度所需要的信息
>实现与其他进程的同步与通信  （每个进程中都要设置相应的用于同步的信号量）



### PCB的信息

#### 1. 进程标识符

用于唯一地标识一个进程

一个进程通常有两种标识符：

**①外部标识符**

为了方便用户（进程）对进程的访问， 须为每个进程设置一个外部标识符

为了描述进程的家族关系，还应设置**父进程标识符**和**子进程标识符**

此外， 还可设置用户标识符，以指示拥有该进程的用户

**②内部标识符**

为了方便系统对进程的使用

赋予每个进程唯一的一个数字标识符，它通常是一个进程的序号

#### 2. 处理机状态

也称为处理机状态信息/处理机上下文

由通用寄存器、指令计数器等寄存器组成，进程切换时能保持断点处的状态信息

#### 3. 进程调度信息

包括   **进程状态   进程优先级   进程调度所需要的其他信息   事件**

#### 4. 进程控制信息

包括   **程序和数据的地址   进程同步和通信机制   资源清单   链接指针**



### PCB的组织方式

#### 1. 线性方式

一张线性表，适合数据量不多的情况

#### 2. 链接方式

通过PCB中的链接字，将具有相同状态的进程的PCB分别链接成一个队列

这样即可形成**就绪队列**、若干个**阻塞队列**和**空闲队列**等

#### 3. 索引方式

系统根据所有进程状态的不同，建立几张索引表，如**就绪索引表**、**阻塞索引表**等，记录对应PCB的内存地址



## 2.3 进程控制



### 进程创建

引起一个进程去创建另一个进程的典型事件有4类

用户登录   作业调度   提供服务   用户请求

#### 创建步骤

申请空白PCB

为新进程分配其运行所需的资源

初始化PCB

插入就绪队列



### 进程终止

正常结束

异常结束

```
越界错  保护错  指令错  特权指令错  运行超时  等待超时  算术运算错  I/O错
```

外界干扰干预

```
操作员或OS干预    父进程请求    父进程终止
```



### 进程阻塞与唤醒

阻塞：进程因等待、请求资源失败而进入阻塞队列

唤醒：从阻塞队列中移出，阻塞变就绪状态，PCB插入就绪队列

**Block 和 Wakeup 要成对出现**



### 进程挂起与激活

挂起：活动状态 $\rightarrow$ 静止状态

激活：静止状态 $\rightarrow$ 活动状态

**Suspend 和 Active** 



## 2.4 进程通信



### 低级通信

①效率低  ②通信对用户不透明



### 高级通信

①使用方便  ②高效地传送大量数据 

高级通信机制可归结为4类： 共享存储器系统   管道通信系统   消息传递系统   客户机-服务器系统

高级通信实现方式： 直接通信   间接通信（信箱通信）

#### 直接通信方式

①对称寻址方式  一对一  要指定发送和接收的名称

②非对称寻址方式  一对多，接收方的变量id可以是任意发送方的id

#### 间接通信

发送和接收方之间多了个信箱中转站，信箱包括信箱头 (存标识符) 和信箱体 (存消息)

**信箱的类型**

①私用信箱，用户进程可为自己建立，并将其作为该进程的一部分；

②公用信箱，由OS创建，并提供给系统中的所有核准进程使用；

③共享信箱，由某进程创建，在创建时或创建后，须指明它是可共享的，以及共享进程（用户）的名字



## 2.5 线程的基本概念

省流：线程的进程的子集，一进程可由多线程组成

概念：进程是拥有资源的基本单位，线程作为调度和分派的基本单位

线程本身不拥有系统资源，仅有一点保证独立运行的资源

同一进程的多线程独立性明显低于多进程

**线程控制块（TCB）**



## 2.6 线程的实现



### 内核支持线程（KST）

kernel supported thread

为了对内核支持线程进行控制和管理，在内核空间也为每个内核支持线程设置了一个TCB

内核根据该TCB来感知某线程的存在，并对其加以控制。当前大多数OS都支持KST

缺点：需要切换用户态和内核态



### 用户级线程（ULT）

user level thread

在用户空间中实现的，与内核无关

缺点：一个线程阻塞时，同一进程内的线程都会阻塞（单线程，无多线程）



用户级线程：以进程为单位进行，平均分配给每个进程的CPU时间

内核支持线程：以线程为单位进行，平均分配给每个线程的CPU时间



### ULT KST 组合方式

一对一  一用户线程映射到一内核线程

多对一  多用户线程映射到一内核线程

多对多  多用户线程映射到多内核线程 （用户线程数量 >= 内核线程）

