# 6、虚拟存储器



## 6.1 虚拟存储器概述

上一章讲的方法，作业全部装入内存才能运行，导致有时作业太大无法装下

那只能 扩大内存 、 逻辑上扩充内存容量（虚拟存储器）

<span style="font-size:1.4rem; background: rgb(255,150,150);">**局部性原理（空间局部性、时间局部性）**</span>

局部性是指在计算机系统中，访问内存或缓存的数据往往会呈现一定的空间或时间上的**局部集中性**。

局部性原理
>程序执行时,除了少部分的转移和过程调用外,在大多数情况下仍然是顺序执行的。
>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域,过程调用的深度一般小于5。程序将会在一段时间内都局限在这些过程的范围内运行。
>程序中存在许多循环结构,多次执行。
>对数据结构的处理局限于很小的范围。

时间局部性：一条指令被执行了,则在不久的将来它可能再被执行。

空间局部性：若某一存储单元被使用,则在一定时间内,与该存储单元相邻的单元可能被使用。

### 虚拟存储器

具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储器系统，能通过页面调度算法**将页面在内存、外存中切换**。

#### 特征

多次性：作业中的程序和数据允许被分成多次调入内存

对换性：作业运行时无须常驻内存（可能换到外存中）

虚拟性：从逻辑上扩充了内存容量,使用户看到的内存容量远大于实际内存容量

#### 实现方法

请求分页系统、请求分段系统、段页式虚拟存储器

<span style="font-size:1.4rem; background: rgb(255,150,150);">**虚拟存储和常规存储的区别**</span>

<span style="font-size:1.4rem; background: rgb(255,150,150);">**常规存储：一次性、驻留性；虚拟存储：多次性、对换性**</span>



## 6.2 请求分页存储管理方式

### 硬件支持

#### 请求页表机制

#### 缺页中断机构

#### 地址变换机构

### 内存分配

#### 物理块分配策略

固定分配：为每个进程分配一组数目固定的物理块，在进程运行期间不再改变。 

可变分配：先为每个进程分配一定数目的物理块，然后在进程运行期间，可根据情况做适当的增加或减少。 

局部置换：进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出一页换出，然后再调入一页，以保证分配给 该进程的内存空间不变。 

全局置换：进程在运行中发现缺页，则将OS所保留的空闲物理块，取出一块分配给该进程，或者以所有进程的全部物理 块为目标，选择一块换出，然后将所缺之页调入

#### 物理块分配算法

平均分配算法

按比例分配算法

考虑优先权的分配算法

### 页面调入策略

何时调入？ 预先调入、等有请求时再调入

从何处调入？ 对换区、文件区

1. **交换区**：交换区是主存中的一部分空间，用于存放被操作系统交换出主存的页面。当主存空间不足时，操作系统会将不常用的页面移动到交换区中，以释放出更多的主存空间供其他页面使用。交换区通常位于硬盘上的特定分区或文件中。
2. **文件区**：文件区是外存中的一部分空间，用于存放被操作系统交换出主存的页面文件。当一个页面被交换到外存时，它将被写入一个文件中，这个文件通常称为页面文件或交换文件。文件区可以包含多个页面文件，并且可以根据需要进行动态扩展。

如何调入？ 见下方页面调入方法

缺页率 $f=\frac{F}{A}=\frac{F}{S+F}=\frac{访问失败次数}{成功次数+失败次数}$

### 页面调入方法

找空闲块插入啊，没有空闲块就通过页面置换算法找到"最垃圾的"来置换



## 6.3 页面置换算法

<span style="font-size:1.4rem; background: rgb(255,245,100);">**几种页面置换算法（最佳，先入先出，最近最久未使用，Clock算法）**</span>

### 最佳置换算法(OPT)

被置换的页将是**之后**最长时间不被使用的页

怎么预测未来？无法实现的理想状态！（所以叫最佳嘛没毛病，又没说要能实现）

这种理想状态可以用来评价其他算法

### 先进先出置换算法(FIFO)

总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰

### 最近最久未使用置换算法(LRU)

选择**最近最久**未使用的页面予以淘汰

### Clock置换算法

LRU的近似算法，又称最近未用(NRU)或二次机会页面置换算法，是性能和开销较均衡的算法

CLOCK算法是基于**环形链表**的方式进行页面替换，每次插入就置1，插不进就置0，当查到的位置是0则表示可以插入，最多转两圈可插入

#### 改进的算法

若淘汰的页面没被修改过，则不需要IO操作，否则需要重写写回外存进行数据更新

实现：在环形链表的每个节点多一个属性（修改位M），标记当前页面是否被修改过

### 最少使用算法(LFU)

之前访问最少的页面要被淘汰，需要建一张页面词频表，统计次数最少的页面将被置换

### 页面缓冲算法

引入了一个称为 **页面缓冲区** 的额外内存区域，用于临时存储被替换出去的页面。

这种机制能够减少页面置换的开销并提高内存访问的效率.



## 6.4 抖动与工作集

### 抖动

概念：一个进程的页面经常换入换出

产生原因：进程太多，相应的物理块又太少

根据程序运行的局部性原理，如果能够**预知某段时间内程序要访问的页面**，并将它们预先调入内存，将会大大降低缺页率。

### 工作集

在一个时刻 t ，往回倒退Δ这么大个窗口，形成的时间段中，进程实际要访问的页面的集合。

**非降函数**：同一时刻 t ，你往回倒推的窗口越大，页面集合肯定只升不降啊

<span style="font-size:1.4rem; background: rgb(255,245,100);">**系统产生“抖动”时的解决方法**</span>

<span style="font-size:1.4rem; background: rgb(255,245,100);">**采用局部置换策略、 采用工作集的方法、 利用“L=S”准则调整缺页率、 暂停/撤销部分进程**</span>



## 6.5 请求分段存储管理方式

### 硬件支持

#### 请求段表机制

包括：访问字段A  修改位M ...

#### 缺段中断机构

段不定长，处理比缺页的困难

#### 地址变换机构

调入内存，利用段表来进行地址变换

### 分段的共享

共享段表（count词频表）

共享段的分配

共享段的回收

<span style="font-size:1.4rem; background: rgb(255,245,100);">**虚拟存储器管理采用请求分段/分页系统后，比常规分段/分页系统多了哪些功能**</span>

<span style="font-size:1.4rem; background: rgb(255,245,100);">**缺页/缺段中断机构、页面/段落置换功能**</span>



## 6.6 虚拟存储器实现实例

### 实例1：Windows XP系统

采用**请求页面调度**以及**簇**来实现虚拟存储器

使用簇在处理缺页中断时，不但会调入不在内存中的页（出错页），还会调入出错页周围的页。

### 实例2：Linux系统（以32位为例）

虚拟存储器是大小为4GB的线性虚拟空间。

